# 一、C语言基础小知识点

puts()只能输出字符串，且输出完成后会自动换行。

puts()和printf()支持字符串形式上的分开，但输出时格式还是合在一起的写法——puts("sssssssss" "dddddddddd" "fffffffff")。

sizeof()是操作符，不是函数；后面跟的是变量名称，可以省略括号；是数据类型，必须加上括号。

使用不同的格式控制符可以输出不同类型的整数。%hd——用来输出short int类型，hd是short decimal的缩写。%d用来输出int类型，d是decimal的缩写。%ld用来输出long int类型，ld是long decimal的缩写。

C代码中的二进制和八进制、十六进制的数字表示。二进制——以0b开头，数字0和字母b（不区分大小写）。八进制——以0开头，数字0。十六进制——以0x开头，数字0和字母x（不区分大小写）。二进制的表示，编译器不同可能不能表示。

八进制和十六进制的不同类型格式输出，和十进制的输出一样，把d换成字母o或字母x。

二进制不能实现格式化输出。

不同进制输出时带前缀——#，如%#X

小数的一种智能的输出方式——%g——输出时会对比十进制形式和指数形式，以最短的方式输出小数。

%g默认最多保留6位有效数字，包括整数部分和小数部分；%f和%e默认保留6位小数。

转义字符——八进制形式的转义字符最多跟三个数字，最大取值是\177。十六进制形式的转义字符最多跟两个数字，最大取值是\x7f。

C语言中的表达式和语句的区别。表达式必须有一个执行结果，这个结果必须是一个值。以分号结束的往往是语句。

取余运算的操作数只能是整数。余数的正负由取余符号左边的操作数正负决定。

强制类型转换的格式——(type_name)expression

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的==临时性转换==，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。

printf()格式控制符的形式——%【flag】【width】【.precision】type——flag表示标志字符；-表示左对齐，默认右对齐；+用于整数或者小数，表示输出的正负号，没有时，只有负数才会输出符号；空格，用于整数或者小数，输出值为正时冠以空格，为负时冠以负号；#，对于八进制和十六进制时，表示添加前缀，对于小数时，表示强制输出小数点。width表示最小输出宽度，不足时，默认左边补齐空格。.precision表示输出的小数的位数，多了时按照四舍五入的原则丢弃，少了时在后面补0；也可以用在整数和字符串上，整数时，表示最小输出宽度，不足左边补0，字符串时，表示最大输出宽度，多时截掉。type表示输出类型。

%p以十六进制的形式（带小写的前缀）输出数据的地址。显示的地址是虚拟地址，不等于数据在物理内存中的地址。

C语言获得键盘输入的函数。输入多种类型的数据——scanf。输入单个字符——getchar，getche，getch。获取一行数据，并作为字符串处理——gets。getche位于conio.h头文件中，默认只能在Windows中使用，输入单个字符后会立即读取。getch也和getche一样，会立即读取，只能在Windows中使用，不同是输入时没有回显。gets能读取含有空格的字符串，不管输入多少字符，只要没有按下回车键，就是一个完整的字符串。

运算符的优先级——赋值运算符 < &&和|| < 关系运算符 < 算术运算符 < !非

关系运算符中，<  <=  >  >=  的优先级高，==和!=的优先级低。

关系运算符的运算结果只有0或1，条件成立，为真，为1，条件不成立，为假，为0。关系运算符是左结合的。

switch-case的基本格式

```c
switch(表达式){
        case 整型数值1：
        {
            语句1；
        }
        case 整型数值2：
        {
            语句2；
        }
        default：
        {
            语句n；
        }
}
//case后面必须是一个整数，或者是结果为整数的表达式，不能是小数，也不能包含任何变量。default不是必须的。
```

条件运算符？：的结合方向是自右向左。也就是多个条件运算符嵌套时，先计算右边的整个条件运算符。

for循环。表达式1和表达式3可以是一个简单表达式，也可以是逗号表达式。表达式2一般是关系表达式或逻辑表达式，但也可以是数值或字符，只要其值非零，就执行循环体。

字符数组。在输出时，用%s，后面用数组名称即可。

```c
char str[20]={"stringstringstring"};
char str[20]="stringstringstring";	//常用

char str[]={"stringstringstring"};
char str[]="stringstringstring";	//常用

!!字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值。
```

> 在C语言中，字符串总是以'\0'作为结尾，所以'\0'也被称为字符串结束标志，或者字符串结束符。C语言在处理字符串时，会从前往后逐个扫描字符，一旦遇到'\0'就认为到达了字符串的末尾，就结束处理。没有'\0'就意味着永远也到达不了字符串的结尾。
>
> 由“ ”包围的字符串会自动在末尾添加'\0'，==逐个字符地给数组赋值并不会自动添加'\0'==，在用字符数组存储字符串时，要为'\0'留个位置，所以字符数组的长度至少要比字符串的长度大1。
>
> 在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的零值。
>
> 为了避免读取不到'\0'，可以手动在数组后面添加'\0'，即定义末尾数组下标处数组值为0。或者在定义时，将数组所有元素初始化为0，==如果只初始化部分数组元素，那么剩余的数组元素也会自动初始化为零，即只需要初始化第0个元素为零，剩下的所有元素都是零。==
>
> 但是测试发现，即使没有定义'\0'，好像并不会出现这些问题，莫非这跟编译器有关？

C语言不允许函数嵌套定义，main函数也是一样；但是可以嵌套调用。实参和形参除了在调用时有个赋值的联系外，其余都是毫无联系的，他们分别存储在不同的存储空间，形参一旦调用完后就会被清除。

return语句是提前结束函数的唯一办法。return后面可以跟数据，也可以不跟任何数据，表示什么也不返回，仅仅用来结束函数。

函数声明，函数定义，函数调用——函数声明，告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。函数定义，设计这个函数。函数调用，干它！函数声明的格式，返回值类型、函数名、参数列表，参数列表里可以不写形参，只写数据类型。==有了函数声明，函数定义就可以出现在任何地方了，甚至是其他文件，静态链接库，动态链接库等。==

www.cplusplus.om网站提供所有C语言标准函数的原型，并给出了详细的介绍和使用示例。

在所有函数外部定义的变量称为全局变量，且C语言代码是从前往后执行的。当局部变量和全局变量同名时，优先使用局部变量。全局变量的默认作用域是整个程序，包括源文件和头文件，如果加上关键字static，作用域就变成了当前文件，在其他文件中无效。在一个函数内部修改全局变量的值会影响其他函数，全局变量的值在函数内部被修改后并不会自动恢复，会一直保留该值，直到下次被修改。

C语言代码块——由{ }符号包围的代码块，可以与其他函数一起出现，也可以单独出现。==C语言允许在代码块内部定义变量，这样的变量具有块级作用域，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。for循环也是一样。==

定义和说明类的语句可以放在函数外面，所有具有运算和逻辑处理能力的语句都要放在函数内部，代码演示：

```c
#include<stdio.h>
int a=1;
int b=a+2;	//error
int b=1+2;	//right
int main(){
    return 0;
}
```

预处理的简单小例子（预处理命令都是以#符号开头的）

```c
//程序要求在暂停5秒后结束程序，在Windows和Linux平台下都能运行。
//Windows平台的暂停函数：Sleep，单位是毫秒，包含在<windows.h>头文件中
//Linux平台下的暂停函数：sleep，单位是秒，包含在<unistd.h>头文件中

#include<stdio.h>
//不同的平台下引入不同的头文件
#if _WIN32	//识别Windows平台
#include<windows.h>
#elif __linux__		//识别Linux平台
#include<unistd.h>
#endif

int main(){
    //不同平台下调用不同的函数
    #if _WIN32	//识别Windows平台
    Sleep(5000);
    #elif __linux__		//识别Linux平台
    sleep(5);
    return 0;
}


//预处理之后，对于Windows平台
#include<stdio.h>
#include<windows.h>

int main(){
    Sleep(5000);
    return 0;
}

//对于Linux平台同理
```

```#include```的两种用法——使用尖括号，编译器回到系统路径下查找头文件。使用双引号，编译器首先在当前路径下查找头文件，如果没有找到，再到系统路径下查找。

```#define```宏定义的字符串表达式两边要加括号，否则容易在替换时引起歧义。==宏定义字符串表达式可以是任何语句；行末不加分号；必须写在函数之外，作用域为宏定义命令起到源程序结束，要终止作用域用```#undef```命令；允许嵌套，由预处理程序层层代换；习惯上宏名用大写；可以用宏定义表示数据类型。==在用宏定义表示数据类型时，注意和typedef的区别，前者只是做了简单的替换，后者是定义了一种新的数据类型。

带参数的宏定义：```#define 宏名(形参列表) 字符串```

==带参数的宏定义时，形参不必指明数据类型，宏调用时实参必须要指明数据类型。表达式中的参数也要用括号，避免歧义。==即对于带参数的宏定义，不仅要在参数两侧加括号，还应该在整个字符串外加括号。

条件编译中的预处理命令：

```c
//#if的用法
#if 整型常量表达式1
	程序段1
#elif 整型常量表达式2
	程序段2
#elif 整型常量表达式3
	程序段3
#else
	程序段4
#endif
//整型常量表达式，表达式中不能包含变量，而且结果必须是整数。


//#ifdef的用法
#ifdef 宏名
	程序段1
#else
	程序段2
#endif
//如果当前的宏已被定义过，则对程序段1进行编译，否则对程序段2进行编译。


//#ifndef的用法
#ifndef 宏名
	程序段1
#else
	程序段2
#endif
//如果当前的宏未被定义，则对程序段1进行编译，否则对程序段2进行编译。


*******************************************
以上三者之间的区别：
#if后面跟的是整型常量表达式
#ifdef和#ifndef后面跟的是宏名，不能是其他的
```

定义指针变量时必须带星号，给指针变量赋值时不能带星号。使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价高。

C语言另外一种表示字符串的方法，利用一个char指针指向字符串。如```char *str = "aaaaaaaaaa"```或者```char *str; str = "aaaaaaaaaa";```输出时，用%s和指针名str。

上面的方法和字符数组的区别：字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的数据有读取和写入的权限，常量区的数据只有读取权限。所以第二种方法中，不能修改指针变量指向字符串中的数据，但是可以更改指针变量本身的指向。

给函数传递数组，都不能在函数内部求得数组长度，必须要额外增加一个参数来传递数组长度。

C语言不允许直接传递数组的所有元素，而必须传递数组指针的原因：参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝；内存拷贝，就是指将一块内存上的数据赋值到另一块内存上。数组是一系列数据的集合，数据的数量没有限制，对他们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，所以C语言没有从语法上支持数据集合的直接赋值。

二级指针（指向指针的指针）：指针变量也是一种变量，也会占用存储空间，也可以使用&符号获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号。想要获取指针指向的数据时，一级指针加一个星号，二级指针加两个星号，三级指针加三个星号，以此类推。

指针数组：一个数组中的所有元素保存的都是指针。定义形式为```dataType *arrayName[length];```，指针数组里每个元素的数据类型都不同。

二维数组指针：是一个指针，它指向一个二维数组。

```c
int *(p1[5]);	//指针数组，可以去掉括号；占用sizeof(int)*5个字节的内存

int (*p2)[5];	//二维数组指针，不能去掉括号；占用sizeof(int)个字节的内存
```

函数指针（指向函数的指针）。定义形式为```returnType (*pointerName)(param list);```，returnType为函数返回值类型，pointerName为指针名称，param list为函数参数列表，列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称。

指针的总结：（1）指针变量可以进行加减运算。指针变量的加减运算不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关；（2）给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数。（3）使用指针变量之前一定要初始化，否则就不能确定指针指向哪里如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值NULL；（4）两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数；（5）数组也是有类型的，数组名的本意是表示一组类型相同的数据。只有在定义数组时，或者和sizeof、&运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。

结构体。结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储。结构体成员之间可能存在缝隙，即结构体占用的内存大于等于所有成员占用内存的总和。

结构体指针。在任何表达式中，结构体变量名表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&符号。

枚举类型。定义形式为```enum typeName{valueName1, valueName2......};```typeName是枚举类型的名称，valueName是每个值对应的名字列表，注意最后的分号。==枚举值默认从0开始，默认递增加1。==也可以在给定名字列表中，给每个名字赋值，```enum typeName{valueName1=1, valueName2=2......};```。注意点：（1）枚举列表中的名称的作用范围是main函数内部全局；（2）列表中的名称都是常量，不能对它们赋值，也不能用&符号取得它们的地址。

共用体。定义形式和结构体相同，关键字换成union。共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。共用体占用的内存等于最长的成员占用的内存，使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

位域。在结构体定义时，指定某个成员变量所占用的二进制位数，在定义变量名称时后面加：冒号，再加数字。位域的宽度不能超过它所依附的数据类型的长度，标准规定只有有限的几种数据类型可以用于位域（int、signed int、unsigned int），但编译器在具体实现时都有扩展。C语言禁止&符号获取位域成员的地址，无意义。

位域的具体存储规则。（1）当相邻成员的类型相同时，如果它们的位宽之和小于类型的sizeof大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。（2）当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，而VS不会。（3）如果成员之间穿插着非位域成员，则不会进行压缩。

无名位域。没有名称，只给出数据类型和位宽。用来作填充或者调整成员位置，无名位域不能使用。

typedef和#define的区别。（1）可以使用其他类型说明符对宏类型名进行扩展，但对typedef却不能。（2）在连续定义几个变量的时候，typedef能够保证定义的所有变量均为同一类型，后者则无法保证。

const创建常量。定义形式为```const type name = value;```或者```type const name = value;```，通常使用前者。由于常量一旦被创建后就不能被修改，所以常量必须在定义的同时初始化。==const通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针所指向的数据，可以用const来限制。==非const类型可以降级为const类型，反之不行。

const的指针的小例子：

```c
const int *p1;	//限制指针所指向的数据，数据只读，指针本身的值可以修改
int const *p2;	//同上

int * const p3;	//限制指针，指针只读，但指针所指向的数据可以被修改

const int * const p4;	//指针和指向的数据都只读
int const * const p5;	//同上
```

随机数函数。rand在头文件```<stdlib.h>```中，为标准库函数；random不是标准库函数。rand函数的重新播种，利用时间参数生成随机数种子```srand((unsigned)time(NULL));```，当然还先要导入时间库```#include<time.h>```，随机数种子生成后就可以给某变量生成随机数了```int a = rand();```，需要注意一点，由于时间逐渐递增，对应到随机数生成函数的正太分布图上，随机数会逐渐递增或递减。

随机函数取模，生成一定范围内的随机数。

打开文件。```FILE *fopen(char *filename, char *mode);```，filename为文件名（包括文件路径），mode为打开方式，它们都是字符串。fopen函数会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。所以通常要用一个FILE类型的指针接收返回地址，写作```FILE *fp = fopen(char *filename, char *mode);```。打开文件出错时，fopen函数会返回一个空指针NULL。

基本的文件打开方式：

控制读写权限的字符串（必须指明）

| 打开方式 | 说明                                              |
| -------- | ------------------------------------------------- |
| r        | 只读，文件必须存在                                |
| w        | 写入，不存在则创建，存在则清空                    |
| a        | 追加，不存在则创建，存在则追加到末尾              |
| r+       | 读写，既可读又可写，文件必须存在                  |
| w+       | 写入/更新，既可读又可写，不存在则创建，存在则清空 |
| a+       | 追加/更新，既可读又可写，不存在则创建，存在则追加 |

控制读写方式的字符串（可以不写）

| 打开方式 | 说明             |
| -------- | ---------------- |
| t        | 文本文件，默认值 |
| b        | 二进制文件       |

> 以上都是字符串，在选择打开方式时要加双引号

文件关闭。```int fclose(FILE *fp);```，文件正常关闭时返回0，返回非零表示有错误发生。

字符读取函数fgetc。```int fgetc(FILE *fp);```，读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。EOF的值是一个负数，往往是-1。

字符写入函数fputc。```int fputc(int ch, FILE *fp);```，ch为要写入的字符，fp为文件指针，写入成功时返回写入的字符，失败时返回EOF。

读字符串函数fgets。```char *fgets(char *str, int n, FILE *fp);```，str为字符数组，n为要读取的字符数目，fp为文件指针。读取成功时返回字符数组首地址，即str，失败时返回NULL，如果开始读取时文件内部指针已经指向了文件末尾，将读取不到任何字符，也返回NULL。==读取到的字符串会在末尾自动添加'\0'，所以对于n，实际只读取到了n-1个字符。在读取到n-1个字符之前如果出现了换行，或者读取到了文件末尾，则读取结束。==C语言没有按行读取文件的函数，所以可以把n设置的足够大，每次就可以读取到一行数据。函数遇到换行时，会将换行符一并读取到当前字符串。

写字符串函数fputs。```int fputs(char *str, FILE *fp);```，str为要写入的字符串，fp为文件指针，写入成功返回非负数，失败返回EOF。

以数据块的形式读写文件。fread函数和fwrite函数。对于Windows系统，使用时应该以二进制的形式打开文件。```size_t fread(void *ptr, size_t size, size_t count, FILE *fp);```，```size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp);```。ptr为内存区块的指针，可以是数组、变量、结构体等，fread中的ptr用来存放读取到的数据，fwrite中的ptr用来存放要写入的数据。size，表示每个数据块的字节数。count，表示要读写的数据块的块数。fp表示文件指针。理论上，每次读写size*count个字节的数据。返回值：返回成功读写的块数，即count。如果返回值小于count——对于fwrite，肯定发生了写入错误，可以用ferror函数检测。对于fread，可能读到了文件末尾，可能发生了错误，可以用ferror函数或feof函数检测。

size_t是在stdio.h和stdlib.h头文件中使用typedef定义的数据类型，表示无符号整数，即非负数，常用来表示数量。

==将文件中的位置指针重新定位到文件开头，函数```rewind(fp)```，fp为文件指针。==

格式化读写文件。对象是磁盘文件。```int fscanf(FILE *fp, char * format, ...); int fprintf(FILE *fp, char * format, ...);```，fp为文件指针，format为格式控制字符串，省略号……表示参数列表。使用时与格式化输入输出字符串函数相类似，只是多了文件指针。fprintf返回成功写入的字符的个数，失败则返回负数。 fscanf返回参数列表中被成功赋值的参数个数。

文件定位函数，移动文件内部位置指针，rewind和fseek函数。

```c
void rewind(FILE *fp);

int fseek(FILE *fp, long offset, int origin);
//fp为文件指针，即被移动的文件
//offset为偏移量，即要移动的字节数。为正后移，为负前移
//origin为起始位置，即从何处开始计算偏移量
//C语言规定的三种起始位置：
//|起始点	|常量名	|常量值|
//文件开头	SEEK_SET	0
//当前位置	SEEK_CUR	1
//文件末尾	SEEK_END	2
```

==fseek函数一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错。==

